const mongoose = require('mongoose');
const TenantInvite = require('../models/TenantInvite');
const Owner = require('../models/Owner');
const Tenant = require('../models/Tenant');
const Property = require('../models/Property');
const Chat = require('../models/Chat');
const Message = require('../models/Message');

// Send Tenant Invite to Owner
const sendTenantInvite = async (req, res) => {
  try {
    const {
      propertyId,
      ownerId,
      message,
      inviteType = "rental_interest",
      tenantPreferences = {},
      applicationData = {}
    } = req.body;

    const tenantId = req.user._id;

    console.log(`[TENANT-INVITE] Tenant ${tenantId} sending invite to owner ${ownerId} for property ${propertyId}`);

    // Validate required fields
    if (!propertyId || !ownerId || !message?.trim()) {
      return res.status(400).json({
        success: false,
        message: "Property ID, Owner ID, and message are required"
      });
    }

    // Verify property exists and belongs to the owner
    const property = await Property.findOne({ 
      _id: propertyId, 
      owner: ownerId 
    }).populate('owner', 'fullName profilePhoto phonenumber');

    if (!property) {
      return res.status(404).json({
        success: false,
        message: "Property not found or doesn't belong to the specified owner"
      });
    }

    // Verify owner exists
    const owner = await Owner.findById(ownerId).select('fullName profilePhoto phonenumber');
    if (!owner) {
      return res.status(404).json({
        success: false,
        message: "Owner not found"
      });
    }

    // Verify tenant exists
    const tenant = await Tenant.findById(tenantId).select('fullName profilePhoto phonenumber');
    if (!tenant) {
      return res.status(404).json({
        success: false,
        message: "Tenant not found"
      });
    }

    // Check if there's already a pending invite for this tenant-property combination
    const existingInvite = await TenantInvite.findOne({
      property: propertyId,
      tenant: tenantId,
      owner: ownerId,
      status: "pending",
      expiresAt: { $gt: new Date() }
    });

    if (existingInvite) {
      return res.status(409).json({
        success: false,
        message: "You already have a pending application for this property"
      });
    }

    // Create new tenant invite
    const invite = new TenantInvite({
      property: propertyId,
      tenant: tenantId,
      owner: ownerId,
      inviteType,
      message: message.trim(),
      tenantPreferences,
      applicationData
    });

    await invite.save();

    // Populate the invite for response and auto message generation
    const populatedInvite = await TenantInvite.findById(invite._id)
      .populate('property', 'title propertyType monthlyRent images propertyId address')
      .populate('tenant', 'fullName profilePhoto phonenumber emailId')
      .populate('owner', 'fullName profilePhoto phonenumber');

    // Generate auto message
    const autoMessage = populatedInvite.generateAutoMessage();
    populatedInvite.autoGeneratedMessage = autoMessage;
    await populatedInvite.save();

    // Create or find existing chat between owner and tenant
    let chat = await Chat.findOne({
      participants: { $all: [ownerId, tenantId] },
      isGroupChat: false
    });

    // If no chat exists, create one
    if (!chat) {
      chat = new Chat({
        participants: [ownerId, tenantId],
        isGroupChat: false,
        lastActivity: new Date()
      });
      await chat.save();
      console.log(`[CHAT] Created new chat ${chat._id} for tenant invite`);
    }

    // Create the tenant invite message in the chat
    const inviteMessage = await Message.create({
      chat: chat._id,
      sender: tenantId,
      senderModel: "Tenant",
      messageType: "text",
      content: `ðŸ  **RENTAL APPLICATION**\n\n${autoMessage}\n\nðŸ“‹ **Original Message:**\n${message.trim()}`,
      readBy: [{ user: tenantId, readAt: new Date() }],
      tenancyInviteContext: 'tenant_application', // Mark as tenant application message
      tenancyInviteId: invite._id, // Link to the specific tenant invite
    });

    // Populate sender details
    await inviteMessage.populate({
      path: "sender",
      select: "fullName email phoneNumber profilePhoto userType",
    });

    // Update chat with the invite message
    chat.lastMessage = inviteMessage._id;
    chat.lastActivity = new Date();
    
    // Increment unread count for owner
    chat.incrementUnreadCount(ownerId);
    await chat.save();

    // Send notification to owner
    const io = req.app.get('io');
    if (io) {
      // Send real-time chat message notification
      io.to(chat._id.toString()).emit("new-message", {
        ...inviteMessage.toObject(),
        readBy: inviteMessage.readBy.map((read) => ({
          user: read.user,
          readAt: read.readAt,
        })),
        isReadBySender: true,
        totalParticipants: chat.participants.length,
        readCount: inviteMessage.readBy.length,
        tenancyInviteContext: 'tenant_application', // Mark as tenant application message
      });

      // Send unread count update to owner
      io.to(ownerId.toString()).emit("unread-count-updated", {
        chatId: chat._id,
        unreadCount: chat.getUnreadCount(ownerId),
        newMessage: {
          _id: inviteMessage._id,
          content: inviteMessage.content,
          messageType: inviteMessage.messageType,
          sender: {
            _id: populatedInvite.tenant._id,
            fullName: populatedInvite.tenant.fullName,
          },
          createdAt: inviteMessage.createdAt,
        },
        timestamp: new Date(),
        tenancyInviteContext: 'tenant_application', // Mark as tenant application message
      });

      // Refresh contacts for owner
      io.to(ownerId.toString()).emit("refresh-contacts");

      // Send real-time notification to owner
      io.to(ownerId.toString()).emit('new-tenant-invite', {
        invite: populatedInvite,
        autoMessage: autoMessage,
        chatId: chat._id,
        message: `New rental application from ${populatedInvite.tenant.fullName}`,
        timestamp: new Date(),
        type: 'tenant_invite',
        tenancyInviteContext: 'tenant_application', // Mark as tenant application message
      });

      // Also send to owner's notification room
      io.to(`invite-notifications-${ownerId.toString()}`).emit('tenant-application', {
        type: 'new_tenant_invite',
        invite: populatedInvite,
        autoMessage: autoMessage,
        chatId: chat._id,
        message: `${populatedInvite.tenant.fullName} applied to rent ${populatedInvite.property.title}`,
        timestamp: new Date(),
        tenancyInviteContext: 'tenant_application', // Mark as tenant application message
      });
    }

    res.status(201).json({
      success: true,
      message: "Rental application sent successfully",
      data: {
        invite: populatedInvite,
        chat: chat,
        autoMessage: autoMessage
      }
    });

  } catch (error) {
    console.error('Send tenant invite error:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};

// Get Tenant Invites for Owner
const getTenantInvitesByOwner = async (req, res) => {
  try {
    const ownerId = req.user._id;
    const { status, page = 1, limit = 10 } = req.query;

    console.log(`[TENANT-INVITE] Getting tenant invites for owner ${ownerId}`);

    // Build filter
    const filter = { owner: ownerId };
    if (status) {
      filter.status = status;
    }

    // Expire old invites first
    await TenantInvite.expireOldInvites();

    // Get invites with pagination
    const skip = (page - 1) * limit;
    const invites = await TenantInvite.find(filter)
      .populate('property', 'title propertyType monthlyRent images propertyId address')
      .populate('tenant', 'fullName profilePhoto phonenumber emailId')
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit));

    const totalInvites = await TenantInvite.countDocuments(filter);

    res.json({
      success: true,
      data: {
        invites,
        pagination: {
          currentPage: parseInt(page),
          totalPages: Math.ceil(totalInvites / limit),
          totalInvites,
          hasNext: skip + invites.length < totalInvites,
          hasPrev: page > 1
        }
      }
    });

  } catch (error) {
    console.error('Get tenant invites by owner error:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};

// Get Tenant Invites for Tenant
const getTenantInvitesByTenant = async (req, res) => {
  try {
    const tenantId = req.user._id;
    const { status, page = 1, limit = 10 } = req.query;

    console.log(`[TENANT-INVITE] Getting tenant invites for tenant ${tenantId}`);

    // Build filter
    const filter = { tenant: tenantId };
    if (status) {
      filter.status = status;
    }

    // Expire old invites first
    await TenantInvite.expireOldInvites();

    // Get invites with pagination
    const skip = (page - 1) * limit;
    const invites = await TenantInvite.find(filter)
      .populate('property', 'title propertyType monthlyRent images propertyId address')
      .populate('owner', 'fullName profilePhoto phonenumber')
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit));

    const totalInvites = await TenantInvite.countDocuments(filter);

    res.json({
      success: true,
      data: {
        invites,
        pagination: {
          currentPage: parseInt(page),
          totalPages: Math.ceil(totalInvites / limit),
          totalInvites,
          hasNext: skip + invites.length < totalInvites,
          hasPrev: page > 1
        }
      }
    });

  } catch (error) {
    console.error('Get tenant invites by tenant error:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};

// Accept Tenant Invite (Owner accepting tenant's application)
const acceptTenantInvite = async (req, res) => {
  try {
    const { inviteId } = req.params;
    const { responseMessage = "" } = req.body;
    const ownerId = req.user._id;

    // Find invite
    const invite = await TenantInvite.findById(inviteId)
      .populate('property', 'title propertyType monthlyRent images propertyId address')
      .populate('tenant', 'fullName profilePhoto phonenumber')
      .populate('owner', 'fullName profilePhoto phonenumber');

    if (!invite) {
      return res.status(404).json({
        success: false,
        message: "Application not found"
      });
    }

    // Verify owner authorization
    const inviteOwnerId = invite.owner._id || invite.owner;
    if (inviteOwnerId.toString() !== ownerId.toString()) {
      return res.status(403).json({
        success: false,
        message: "Unauthorized to respond to this application"
      });
    }

    // Check invite status before processing
    if (invite.status !== 'pending') {
      const statusMessages = {
        'accepted': 'This application has already been accepted',
        'declined': 'This application has already been declined', 
        'expired': 'This application has expired and can no longer be processed'
      };
      
      return res.status(400).json({
        success: false,
        message: statusMessages[invite.status] || `This application has already been processed (status: ${invite.status})`,
        data: {
          currentStatus: invite.status,
          processedAt: invite.ownerResponse?.respondedAt || invite.updatedAt,
          chatId: invite.chat || null
        }
      });
    }

    // Check if invite is expired
    if (invite.expiresAt && new Date() > invite.expiresAt) {
      // Auto-expire the invite
      invite.status = 'expired';
      await invite.save();
      
      return res.status(400).json({
        success: false,
        message: "This application has expired and can no longer be processed",
        data: {
          currentStatus: 'expired',
          expiredAt: invite.expiresAt
        }
      });
    }

    // Accept invite and create chat
    const chat = await invite.acceptInvite(responseMessage);

    try {
      // Create automatic acceptance message
      const tenantName = invite.tenant.fullName || 'Tenant';
      const ownerName = invite.owner.fullName || 'Owner';
      const propertyTitle = invite.property.title || 'the property';
      
      const acceptanceAutoMessage = `Hi, ${tenantName}! ðŸ˜Š`;
      const acceptanceResponseMessage = `Thank you for your application. I am pleased to accept your rental application for ${propertyTitle}. Let's discuss the next steps to proceed.`;

      console.log(`[AUTO-MESSAGE] Creating acceptance auto messages for tenant invite ${inviteId}`);

      // Create the automatic greeting message
      const greetingMessage = await Message.create({
        chat: chat._id,
        sender: ownerId,
        senderModel: "Owner",
        messageType: "text",
        content: acceptanceAutoMessage,
        tenancyInviteContext: 'owner_only', // Owner auto message
        tenancyInviteId: invite._id,
        readBy: [{ user: ownerId, readAt: new Date() }]
      });

      // Create the acceptance response message
      const responseAutoMessage = await Message.create({
        chat: chat._id,
        sender: ownerId,
        senderModel: "Owner",
        messageType: "text",
        content: responseMessage.trim() || acceptanceResponseMessage,
        tenancyInviteContext: 'owner_only', // Owner response message
        tenancyInviteId: invite._id,
        readBy: [{ user: ownerId, readAt: new Date() }]
      });

      console.log(`[AUTO-MESSAGE] Created ${greetingMessage._id} and ${responseAutoMessage._id} for acceptance`);

      // Update chat with the latest message
      chat.lastMessage = responseAutoMessage._id;
      chat.lastActivity = new Date();
      
      // Increment unread count for tenant
      chat.incrementUnreadCount(invite.tenant._id || invite.tenant);
      await chat.save();

      // Send notification to tenant
      const io = req.app.get('io');
      if (io) {
        const tenantId = invite.tenant._id || invite.tenant;
        
        // Real-time notification to tenant
        io.to(tenantId.toString()).emit('tenant-invite-accepted', {
          invite: invite,
          chat: chat,
          message: `${invite.owner.fullName} accepted your rental application!`,
          timestamp: new Date()
        });

        // Notify about new chat creation
        io.to(tenantId.toString()).emit('new-chat', {
          chat: chat,
          message: 'Chat created with owner',
          timestamp: new Date()
        });

        // Send real-time messages for both auto messages
        const greetingMessageData = {
          ...greetingMessage.toObject(),
          sender: {
            _id: ownerId,
            fullName: ownerName,
            userType: 'owner',
            profilePhoto: invite.owner.profilePhoto
          }
        };

        const responseMessageData = {
          ...responseAutoMessage.toObject(),
          sender: {
            _id: ownerId,
            fullName: ownerName,
            userType: 'owner',
            profilePhoto: invite.owner.profilePhoto
          }
        };

        // Send both messages to the chat
        io.to(chat._id.toString()).emit('new-message', greetingMessageData);
        io.to(chat._id.toString()).emit('new-message', responseMessageData);

        // Refresh contacts for tenant
        io.to(tenantId.toString()).emit("refresh-contacts");

        console.log(`[NOTIFICATION] Sent acceptance notification for tenant invite ${inviteId}`);
      }

      res.json({
        success: true,
        message: "Rental application accepted and chat created successfully",
        data: {
          invite: invite,
          chat: chat
        }
      });

    } catch (autoMessageError) {
      console.error('Error creating auto messages for acceptance:', autoMessageError);
      // Still return success since the invite was accepted, just log the auto message error
      res.json({
        success: true,
        message: "Rental application accepted and chat created successfully (auto messages may have failed)",
        data: {
          invite: invite,
          chat: chat
        }
      });
    }

  } catch (error) {
    console.error('Accept tenant invite error:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};

// Decline Tenant Invite (Owner declining tenant's application)
const declineTenantInvite = async (req, res) => {
  try {
    const { inviteId } = req.params;
    const { responseMessage = "" } = req.body;
    const ownerId = req.user._id;

    // Find invite
    const invite = await TenantInvite.findById(inviteId)
      .populate('property', 'title propertyType monthlyRent images propertyId address')
      .populate('tenant', 'fullName profilePhoto phonenumber')
      .populate('owner', 'fullName profilePhoto phonenumber');

    if (!invite) {
      return res.status(404).json({
        success: false,
        message: "Application not found"
      });
    }

    // Verify owner authorization
    const inviteOwnerId = invite.owner._id || invite.owner;
    if (inviteOwnerId.toString() !== ownerId.toString()) {
      return res.status(403).json({
        success: false,
        message: "Unauthorized to respond to this application"
      });
    }

    // Check invite status before processing
    if (invite.status !== 'pending') {
      const statusMessages = {
        'accepted': 'This application has already been accepted',
        'declined': 'This application has already been declined', 
        'expired': 'This application has expired and can no longer be processed'
      };
      
      return res.status(400).json({
        success: false,
        message: statusMessages[invite.status] || `This application has already been processed (status: ${invite.status})`,
        data: {
          currentStatus: invite.status,
          processedAt: invite.ownerResponse?.respondedAt || invite.updatedAt
        }
      });
    }

    // Check if invite is expired
    if (invite.expiresAt && new Date() > invite.expiresAt) {
      // Auto-expire the invite
      invite.status = 'expired';
      await invite.save();
      
      return res.status(400).json({
        success: false,
        message: "This application has expired and can no longer be processed",
        data: {
          currentStatus: 'expired',
          expiredAt: invite.expiresAt
        }
      });
    }

    // Decline invite
    await invite.declineInvite(responseMessage);

    try {
      // Create automatic decline messages
      const tenantName = invite.tenant.fullName || 'Tenant';
      const ownerName = invite.owner.fullName || 'Owner';
      const propertyTitle = invite.property.title || 'the property';
      
      const declineAutoMessage = `Hi, ${tenantName}! ðŸ˜Š`;
      const declineResponseMessage = `Thank you for your interest in ${propertyTitle}. After careful consideration, I have decided to proceed with another applicant at this time.`;

      console.log(`[AUTO-MESSAGE] Creating decline auto messages for tenant invite ${inviteId}`);

      // Find or create chat between owner and tenant for decline message
      let chat = await Chat.findOne({
        participants: { $all: [ownerId, invite.tenant._id || invite.tenant] },
        isGroupChat: false
      });

      // If no chat exists, create one for the decline response
      if (!chat) {
        chat = new Chat({
          participants: [ownerId, invite.tenant._id || invite.tenant],
          isGroupChat: false,
          lastActivity: new Date()
        });
        await chat.save();
        console.log(`[CHAT] Created new chat ${chat._id} for tenant invite decline`);
      }

      // Create the automatic greeting message
      const greetingMessage = await Message.create({
        chat: chat._id,
        sender: ownerId,
        senderModel: "Owner",
        messageType: "text",
        content: declineAutoMessage,
        tenancyInviteContext: 'owner_only', // Owner auto message
        tenancyInviteId: invite._id,
        readBy: [{ user: ownerId, readAt: new Date() }]
      });

      // Create the decline response message
      const responseAutoMessage = await Message.create({
        chat: chat._id,
        sender: ownerId,
        senderModel: "Owner",
        messageType: "text",
        content: responseMessage.trim() || declineResponseMessage,
        tenancyInviteContext: 'owner_only', // Owner response message
        tenancyInviteId: invite._id,
        readBy: [{ user: ownerId, readAt: new Date() }]
      });

      console.log(`[AUTO-MESSAGE] Created ${greetingMessage._id} and ${responseAutoMessage._id} for decline`);

      // Update chat with the latest message
      chat.lastMessage = responseAutoMessage._id;
      chat.lastActivity = new Date();
      
      // Increment unread count for tenant
      chat.incrementUnreadCount(invite.tenant._id || invite.tenant);
      await chat.save();

      // Send notification to tenant
      const io = req.app.get('io');
      if (io) {
        const tenantId = invite.tenant._id || invite.tenant;
        
        // Real-time notification to tenant
        io.to(tenantId.toString()).emit('tenant-invite-declined', {
          invite: invite,
          chat: chat,
          message: `${invite.owner.fullName} declined your rental application`,
          timestamp: new Date()
        });

        // Send real-time messages for both auto messages
        const greetingMessageData = {
          ...greetingMessage.toObject(),
          sender: {
            _id: ownerId,
            fullName: ownerName,
            userType: 'owner',
            profilePhoto: invite.owner.profilePhoto
          }
        };

        const responseMessageData = {
          ...responseAutoMessage.toObject(),
          sender: {
            _id: ownerId,
            fullName: ownerName,
            userType: 'owner',
            profilePhoto: invite.owner.profilePhoto
          }
        };

        // Send both messages to the chat
        io.to(chat._id.toString()).emit('new-message', greetingMessageData);
        io.to(chat._id.toString()).emit('new-message', responseMessageData);

        // Refresh contacts for tenant
        io.to(tenantId.toString()).emit("refresh-contacts");

        console.log(`[NOTIFICATION] Sent decline notification for tenant invite ${inviteId}`);
      }

      res.json({
        success: true,
        message: "Rental application declined successfully",
        data: {
          invite: invite,
          chat: chat
        }
      });

    } catch (autoMessageError) {
      console.error('Error creating auto messages for decline:', autoMessageError);
      // Still return success since the invite was declined, just log the auto message error
      res.json({
        success: true,
        message: "Rental application declined successfully (auto messages may have failed)",
        data: {
          invite: invite
        }
      });
    }

  } catch (error) {
    console.error('Decline tenant invite error:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};

// Get single tenant invite details
const getTenantInviteDetails = async (req, res) => {
  try {
    const { inviteId } = req.params;
    const userId = req.user._id;

    const invite = await TenantInvite.findById(inviteId)
      .populate('property', 'title propertyType monthlyRent images propertyId address')
      .populate('tenant', 'fullName profilePhoto phonenumber emailId')
      .populate('owner', 'fullName profilePhoto phonenumber')
      .populate('chat', 'participants lastActivity');

    if (!invite) {
      return res.status(404).json({
        success: false,
        message: "Application not found"
      });
    }

    // Verify user authorization (must be the owner or tenant)
    const isOwner = (invite.owner._id || invite.owner).toString() === userId.toString();
    const isTenant = (invite.tenant._id || invite.tenant).toString() === userId.toString();

    if (!isOwner && !isTenant) {
      return res.status(403).json({
        success: false,
        message: "Unauthorized to view this application"
      });
    }

    res.json({
      success: true,
      data: invite
    });

  } catch (error) {
    console.error('Get tenant invite details error:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};

module.exports = {
  sendTenantInvite,
  getTenantInvitesByOwner,
  getTenantInvitesByTenant,
  acceptTenantInvite,
  declineTenantInvite,
  getTenantInviteDetails
};