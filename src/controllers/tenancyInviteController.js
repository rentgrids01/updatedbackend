const TenancyInvite = require("../models/TenancyInvite");
const Property = require("../models/Property");
const Owner = require("../models/Owner");
const Tenant = require("../models/Tenant");
const Chat = require("../models/Chat");
const Message = require("../models/Message");

// Send Tenancy Invite (Owner to Tenant)
const sendTenancyInvite = async (req, res) => {
  try {
    const { 
      tenantId, 
      propertyId, 
      message, 
      inviteType = "tenancy_offer",
      rentalTerms = {} 
    } = req.body;
    const ownerId = req.user._id;

    // Validate input
    if (!tenantId || !propertyId || !message) {
      return res.status(400).json({
        success: false,
        message: "Tenant ID, Property ID, and message are required"
      });
    }

    // Validate that the user is an owner
    if (req.user.userType !== 'owner') {
      return res.status(403).json({
        success: false,
        message: "Only property owners can send tenancy invites"
      });
    }

    // Check if property exists and belongs to the owner
    const property = await Property.findById(propertyId);
    if (!property) {
      return res.status(404).json({
        success: false,
        message: "Property not found"
      });
    }

    if (property.owner.toString() !== ownerId.toString()) {
      return res.status(403).json({
        success: false,
        message: "You can only send invites for your own properties"
      });
    }

    // Check if tenant exists
    const tenant = await Tenant.findById(tenantId);
    if (!tenant) {
      return res.status(404).json({
        success: false,
        message: "Tenant not found"
      });
    }

    // Check if there's already a pending invite for this tenant-property combination
    const existingInvite = await TenancyInvite.findOne({
      property: propertyId,
      tenant: tenantId,
      owner: ownerId,
      status: "pending",
      expiresAt: { $gt: new Date() }
    });

    if (existingInvite) {
      return res.status(409).json({
        success: false,
        message: "You already have a pending invite for this tenant and property"
      });
    }

    // Create new tenancy invite
    const invite = new TenancyInvite({
      property: propertyId,
      tenant: tenantId,
      owner: ownerId,
      inviteType,
      message: message.trim(),
      rentalTerms
    });

    await invite.save();

    // Populate the invite for response and auto message generation
    const populatedInvite = await TenancyInvite.findById(invite._id)
      .populate('property', 'title propertyType monthlyRent images propertyId address')
      .populate('tenant', 'fullName profilePhoto phonenumber emailId')
      .populate('owner', 'fullName profilePhoto phonenumber');

    // Generate auto message
    const autoMessage = populatedInvite.generateAutoMessage();
    populatedInvite.autoGeneratedMessage = autoMessage;
    await populatedInvite.save();

    // Create or find existing chat between owner and tenant
    let chat = await Chat.findOne({
      participants: { $all: [ownerId, tenantId] },
      isGroupChat: false
    });

    // If no chat exists, create one
    if (!chat) {
      chat = new Chat({
        participants: [ownerId, tenantId],
        isGroupChat: false,
        lastActivity: new Date()
      });
      await chat.save();
      console.log(`[CHAT] Created new chat ${chat._id} for tenancy invite`);
    }

    // Create the tenancy invite message in the chat
    const inviteMessage = await Message.create({
      chat: chat._id,
      sender: ownerId,
      senderModel: "Owner",
      messageType: "text",
      content: `🏠 **TENANCY INVITATION**\n\n${autoMessage}\n\n📋 **Original Message:**\n${message.trim()}`,
      readBy: [{ user: ownerId, readAt: new Date() }],
      tenancyInviteContext: 'invite_message', // Mark as invite message
      tenancyInviteId: invite._id, // Link to the specific tenancy invite
    });

    // Populate sender details
    await inviteMessage.populate({
      path: "sender",
      select: "fullName email phoneNumber profilePhoto userType",
    });

    // Update chat with the invite message
    chat.lastMessage = inviteMessage._id;
    chat.lastActivity = new Date();
    
    // Increment unread count for tenant
    chat.incrementUnreadCount(tenantId);
    await chat.save();

    // Send notification to tenant
    const io = req.app.get('io');
    if (io) {
      // Send real-time chat message notification
      io.to(chat._id.toString()).emit("new-message", {
        ...inviteMessage.toObject(),
        readBy: inviteMessage.readBy.map((read) => ({
          user: read.user,
          readAt: read.readAt,
        })),
        isReadBySender: true,
        totalParticipants: chat.participants.length,
        readCount: inviteMessage.readBy.length,
        tenancyInviteContext: 'invite_message', // Mark as invite message
      });

      // Send unread count update to tenant
      io.to(tenantId.toString()).emit("unread-count-updated", {
        chatId: chat._id,
        unreadCount: chat.getUnreadCount(tenantId),
        newMessage: {
          _id: inviteMessage._id,
          content: inviteMessage.content,
          messageType: inviteMessage.messageType,
          sender: {
            _id: populatedInvite.owner._id,
            fullName: populatedInvite.owner.fullName,
          },
          createdAt: inviteMessage.createdAt,
        },
        timestamp: new Date(),
        tenancyInviteContext: 'invite_message', // Mark as invite message
      });

      // Refresh contacts for tenant
      io.to(tenantId.toString()).emit("refresh-contacts");

      // Send real-time notification to tenant
      io.to(tenantId.toString()).emit('new-tenancy-invite', {
        invite: populatedInvite,
        autoMessage: autoMessage,
        chatId: chat._id,
        message: `New tenancy invitation from ${populatedInvite.owner.fullName}`,
        timestamp: new Date(),
        type: 'tenancy_invite',
        tenancyInviteContext: 'invite_message', // Mark as invite message
      });

      // Also send to tenant's notification room
      io.to(`invite-notifications-${tenantId.toString()}`).emit('tenancy-invitation', {
        type: 'new_tenancy_invite',
        invite: populatedInvite,
        autoMessage: autoMessage,
        chatId: chat._id,
        message: `${populatedInvite.owner.fullName} invited you to rent ${populatedInvite.property.title}`,
        timestamp: new Date(),
        tenancyInviteContext: 'invite_message', // Mark as invite message
      });

      console.log(`[NOTIFICATION] Sent tenancy invite notification to tenant ${tenantId}`);
    }

    res.status(201).json({
      success: true,
      message: "Tenancy invite sent successfully and chat message created",
      data: {
        invite: populatedInvite,
        autoGeneratedMessage: autoMessage,
        chat: {
          _id: chat._id,
          participants: chat.participants,
          lastActivity: chat.lastActivity
        },
        inviteMessage: {
          _id: inviteMessage._id,
          content: inviteMessage.content,
          messageType: inviteMessage.messageType,
          createdAt: inviteMessage.createdAt
        }
      }
    });

  } catch (error) {
    console.error('Send tenancy invite error:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};

// Get Pending Invites for Tenant
const getPendingInvitesForTenant = async (req, res) => {
  try {
    const tenantId = req.user._id;

    const invites = await TenancyInvite.getPendingInvitesForTenant(tenantId);

    res.json({
      success: true,
      message: "Pending invites fetched successfully",
      data: invites
    });

  } catch (error) {
    console.error('Get pending invites error:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};

// Get All Invites for Tenant (pending, accepted, declined)
const getAllInvitesForTenant = async (req, res) => {
  try {
    const tenantId = req.user._id;
    const { status, page = 1, limit = 10 } = req.query;

    const query = { tenant: tenantId };
    if (status) {
      query.status = status;
    }

    const invites = await TenancyInvite.find(query)
      .populate('property', 'title propertyType monthlyRent images propertyId address')
      .populate('owner', 'fullName profilePhoto phonenumber')
      .sort({ createdAt: -1 })
      .limit(limit * 1)
      .skip((page - 1) * limit);

    const total = await TenancyInvite.countDocuments(query);

    res.json({
      success: true,
      message: "Invites fetched successfully",
      data: invites,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(total / limit),
        totalItems: total,
        itemsPerPage: parseInt(limit)
      }
    });

  } catch (error) {
    console.error('Get all invites for tenant error:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};

// Get Invites Sent by Owner
const getInvitesByOwner = async (req, res) => {
  try {
    const ownerId = req.user._id;
    const { status, page = 1, limit = 10 } = req.query;

    const query = { owner: ownerId };
    if (status) {
      query.status = status;
    }

    const invites = await TenancyInvite.find(query)
      .populate('property', 'title propertyType monthlyRent images propertyId')
      .populate('tenant', 'fullName profilePhoto phonenumber')
      .sort({ createdAt: -1 })
      .limit(limit * 1)
      .skip((page - 1) * limit);

    const total = await TenancyInvite.countDocuments(query);

    res.json({
      success: true,
      message: "Sent invites fetched successfully",
      data: invites,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(total / limit),
        totalItems: total,
        itemsPerPage: parseInt(limit)
      }
    });

  } catch (error) {
    console.error('Get invites by owner error:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};

// Accept Tenancy Invite and Create Chat
const acceptTenancyInvite = async (req, res) => {
  try {
    const { inviteId } = req.params;
    const { responseMessage = "" } = req.body;
    const tenantId = req.user._id;

    // Find invite
    const invite = await TenancyInvite.findById(inviteId)
      .populate('property', 'title propertyType monthlyRent images propertyId address')
      .populate('tenant', 'fullName profilePhoto phonenumber')
      .populate('owner', 'fullName profilePhoto phonenumber');

    if (!invite) {
      return res.status(404).json({
        success: false,
        message: "Invite not found"
      });
    }

    // Verify tenant authorization
    const inviteTenantId = invite.tenant._id || invite.tenant;
    if (inviteTenantId.toString() !== tenantId.toString()) {
      return res.status(403).json({
        success: false,
        message: "Unauthorized to respond to this invite"
      });
    }

    // Check invite status before processing
    if (invite.status !== 'pending') {
      const statusMessages = {
        'accepted': 'This invitation has already been accepted',
        'declined': 'This invitation has already been declined', 
        'expired': 'This invitation has expired and can no longer be processed'
      };
      
      return res.status(400).json({
        success: false,
        message: statusMessages[invite.status] || `This invitation has already been processed (status: ${invite.status})`,
        data: {
          currentStatus: invite.status,
          processedAt: invite.tenantResponse?.respondedAt || invite.updatedAt,
          chatId: invite.chat || null
        }
      });
    }

    // Check if invite is expired
    if (invite.expiresAt && new Date() > invite.expiresAt) {
      // Auto-expire the invite
      invite.status = 'expired';
      await invite.save();
      
      return res.status(400).json({
        success: false,
        message: "This invitation has expired and can no longer be processed",
        data: {
          currentStatus: 'expired',
          expiredAt: invite.expiresAt
        }
      });
    }

    // Accept invite and create chat
    const chat = await invite.acceptInvite(responseMessage);

    try {
      // Create automatic acceptance message
      const ownerName = invite.owner.fullName || 'Owner';
      const tenantName = invite.tenant.fullName || 'Tenant';
      const propertyTitle = invite.property.title || 'the property';
      
      const acceptanceAutoMessage = `Hi, ${ownerName}! 😊`;
      const acceptanceResponseMessage = `Thank you for the offer. I am happy to accept the terms and conditions we discussed. Please let me know the next steps to proceed.`;

      console.log(`[AUTO-MESSAGE] Creating acceptance auto messages for invite ${inviteId}`);

      // Create the automatic greeting message
      const greetingMessage = await Message.create({
        chat: chat._id,
        sender: tenantId,
        senderModel: "Tenant",
        messageType: "text",
        content: acceptanceAutoMessage,
        tenancyInviteContext: 'tenant_only', // Tenant auto message
        tenancyInviteId: invite._id,
        readBy: [{ user: tenantId, readAt: new Date() }]
      });

      // Create the acceptance response message
      const responseAutoMessage = await Message.create({
        chat: chat._id,
        sender: tenantId,
        senderModel: "Tenant",
        messageType: "text",
        content: responseMessage.trim() || acceptanceResponseMessage,
        tenancyInviteContext: 'tenant_only', // Tenant response message
        tenancyInviteId: invite._id,
        readBy: [{ user: tenantId, readAt: new Date() }]
      });

      console.log(`[AUTO-MESSAGE] Created ${greetingMessage._id} and ${responseAutoMessage._id} for acceptance`);

      // Update chat with the latest message
      chat.lastMessage = responseAutoMessage._id;
      chat.lastActivity = new Date();
      
      // Increment unread count for owner
      chat.incrementUnreadCount(invite.owner._id || invite.owner);
      await chat.save();

      // Send notification to owner
      const io = req.app.get('io');
      if (io) {
        const ownerId = invite.owner._id || invite.owner;
        
        // Real-time notification to owner
        io.to(ownerId.toString()).emit('tenancy-invite-accepted', {
          invite: invite,
          chat: chat,
          message: `${invite.tenant.fullName} accepted your tenancy invitation!`,
          timestamp: new Date()
        });

        // Notify about new chat creation
        io.to(ownerId.toString()).emit('new-chat', {
          chat: chat,
          message: 'Chat created with tenant',
          timestamp: new Date()
        });

        // Send real-time messages for both auto messages
        const greetingMessageData = {
          ...greetingMessage.toObject(),
          sender: {
            _id: tenantId,
            fullName: tenantName,
            userType: 'tenant',
            profilePhoto: invite.tenant.profilePhoto
          }
        };

        const responseMessageData = {
          ...responseAutoMessage.toObject(),
          sender: {
            _id: tenantId,
            fullName: tenantName,
            userType: 'tenant',
            profilePhoto: invite.tenant.profilePhoto
          }
        };

        // Send both messages to the chat
        io.to(chat._id.toString()).emit('new-message', greetingMessageData);
        io.to(chat._id.toString()).emit('new-message', responseMessageData);

        // Refresh contacts for owner
        io.to(ownerId.toString()).emit("refresh-contacts");

        console.log(`[NOTIFICATION] Sent acceptance notification for invite ${inviteId}`);
      }

      res.json({
        success: true,
        message: "Tenancy invite accepted and chat created successfully",
        data: {
          invite: invite,
          chat: chat
        }
      });

    } catch (autoMessageError) {
      console.error('Error creating auto messages for acceptance:', autoMessageError);
      // Still return success since the invite was accepted, just log the auto message error
      res.json({
        success: true,
        message: "Tenancy invite accepted and chat created successfully (auto messages may have failed)",
        data: {
          invite: invite,
          chat: chat
        }
      });
    }

  } catch (error) {
    console.error('Accept tenancy invite error:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};

// Decline Tenancy Invite
const declineTenancyInvite = async (req, res) => {
  try {
    const { inviteId } = req.params;
    const { responseMessage = "" } = req.body;
    const tenantId = req.user._id;

    // Find invite
    const invite = await TenancyInvite.findById(inviteId)
      .populate('property', 'title propertyType monthlyRent images propertyId address')
      .populate('tenant', 'fullName profilePhoto phonenumber')
      .populate('owner', 'fullName profilePhoto phonenumber');

    if (!invite) {
      return res.status(404).json({
        success: false,
        message: "Invite not found"
      });
    }

    // Verify tenant authorization
    const inviteTenantId = invite.tenant._id || invite.tenant;
    if (inviteTenantId.toString() !== tenantId.toString()) {
      return res.status(403).json({
        success: false,
        message: "Unauthorized to respond to this invite"
      });
    }

    // Check invite status before processing
    if (invite.status !== 'pending') {
      const statusMessages = {
        'accepted': 'This invitation has already been accepted',
        'declined': 'This invitation has already been declined', 
        'expired': 'This invitation has expired and can no longer be processed'
      };
      
      return res.status(400).json({
        success: false,
        message: statusMessages[invite.status] || `This invitation has already been processed (status: ${invite.status})`,
        data: {
          currentStatus: invite.status,
          processedAt: invite.tenantResponse?.respondedAt || invite.updatedAt
        }
      });
    }

    // Check if invite is expired
    if (invite.expiresAt && new Date() > invite.expiresAt) {
      // Auto-expire the invite
      invite.status = 'expired';
      await invite.save();
      
      return res.status(400).json({
        success: false,
        message: "This invitation has expired and can no longer be processed",
        data: {
          currentStatus: 'expired',
          expiredAt: invite.expiresAt
        }
      });
    }

    // Decline invite
    await invite.declineInvite(responseMessage);

    try {
      // Create automatic decline messages
      const ownerName = invite.owner.fullName || 'Owner';
      const tenantName = invite.tenant.fullName || 'Tenant';
      const propertyTitle = invite.property.title || 'the property';
      
      const declineAutoMessage = `Hi, ${ownerName}! 😊`;
      const declineResponseMessage = `Thank you for the offer. I appreciate the opportunity, but I have to decline this invitation at this time.`;

      console.log(`[AUTO-MESSAGE] Creating decline auto messages for invite ${inviteId}`);

      // Find or create chat between owner and tenant for decline message
      let chat = await Chat.findOne({
        participants: { $all: [invite.owner._id || invite.owner, tenantId] },
        isGroupChat: false
      });

      // If no chat exists, create one for the decline response
      if (!chat) {
        chat = new Chat({
          participants: [invite.owner._id || invite.owner, tenantId],
          isGroupChat: false,
          lastActivity: new Date()
        });
        await chat.save();
        console.log(`[CHAT] Created new chat ${chat._id} for tenancy decline`);
      }

      // Create the automatic greeting message
      const greetingMessage = await Message.create({
        chat: chat._id,
        sender: tenantId,
        senderModel: "Tenant",
        messageType: "text",
        content: declineAutoMessage,
        tenancyInviteContext: 'tenant_only', // Tenant auto message
        tenancyInviteId: invite._id,
        readBy: [{ user: tenantId, readAt: new Date() }]
      });

      // Create the decline response message
      const responseAutoMessage = await Message.create({
        chat: chat._id,
        sender: tenantId,
        senderModel: "Tenant",
        messageType: "text",
        content: responseMessage.trim() || declineResponseMessage,
        tenancyInviteContext: 'tenant_only', // Tenant response message
        tenancyInviteId: invite._id,
        readBy: [{ user: tenantId, readAt: new Date() }]
      });

      console.log(`[AUTO-MESSAGE] Created ${greetingMessage._id} and ${responseAutoMessage._id} for decline`);

      // Update chat with the latest message
      chat.lastMessage = responseAutoMessage._id;
      chat.lastActivity = new Date();
      
      // Increment unread count for owner
      chat.incrementUnreadCount(invite.owner._id || invite.owner);
      await chat.save();

      // Send notification to owner
      const io = req.app.get('io');
      if (io) {
        const ownerId = invite.owner._id || invite.owner;
        
        // Real-time notification to owner
        io.to(ownerId.toString()).emit('tenancy-invite-declined', {
          invite: invite,
          chat: chat,
          message: `${invite.tenant.fullName} declined your tenancy invitation`,
          timestamp: new Date()
        });

        // Send real-time messages for both auto messages
        const greetingMessageData = {
          ...greetingMessage.toObject(),
          sender: {
            _id: tenantId,
            fullName: tenantName,
            userType: 'tenant',
            profilePhoto: invite.tenant.profilePhoto
          }
        };

        const responseMessageData = {
          ...responseAutoMessage.toObject(),
          sender: {
            _id: tenantId,
            fullName: tenantName,
            userType: 'tenant',
            profilePhoto: invite.tenant.profilePhoto
          }
        };

        // Send both messages to the chat
        io.to(chat._id.toString()).emit('new-message', greetingMessageData);
        io.to(chat._id.toString()).emit('new-message', responseMessageData);

        // Refresh contacts for owner
        io.to(ownerId.toString()).emit("refresh-contacts");

        console.log(`[NOTIFICATION] Sent decline notification for invite ${inviteId}`);
      }

      res.json({
        success: true,
        message: "Tenancy invite declined successfully",
        data: {
          invite: invite,
          chat: chat
        }
      });

    } catch (autoMessageError) {
      console.error('Error creating auto messages for decline:', autoMessageError);
      // Still return success since the invite was declined, just log the auto message error
      res.json({
        success: true,
        message: "Tenancy invite declined successfully (auto messages may have failed)",
        data: {
          invite: invite
        }
      });
    }

  } catch (error) {
    console.error('Decline tenancy invite error:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};

// Get Invite Details
const getInviteDetails = async (req, res) => {
  try {
    const { inviteId } = req.params;
    const userId = req.user._id;

    const invite = await TenancyInvite.findById(inviteId)
      .populate('property', 'title propertyType monthlyRent images propertyId address description')
      .populate('tenant', 'fullName profilePhoto phonenumber')
      .populate('owner', 'fullName profilePhoto phonenumber')
      .populate('chat');

    if (!invite) {
      return res.status(404).json({
        success: false,
        message: "Invite not found"
      });
    }

    // Verify user authorization (either tenant or owner)
    const inviteTenantId = invite.tenant._id || invite.tenant;
    const inviteOwnerId = invite.owner._id || invite.owner;
    
    if (inviteTenantId.toString() !== userId.toString() && 
        inviteOwnerId.toString() !== userId.toString()) {
      return res.status(403).json({
        success: false,
        message: "Unauthorized to view this invite"
      });
    }

    res.json({
      success: true,
      message: "Invite details fetched successfully",
      data: invite
    });

  } catch (error) {
    console.error('Get invite details error:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};

// Get Chat from Invite
const getChatFromInvite = async (req, res) => {
  try {
    const { inviteId } = req.params;
    const userId = req.user._id;

    const invite = await TenancyInvite.findById(inviteId)
      .populate('chat');

    if (!invite) {
      return res.status(404).json({
        success: false,
        message: "Invite not found"
      });
    }

    // Verify user authorization
    const inviteTenantId = invite.tenant._id || invite.tenant;
    const inviteOwnerId = invite.owner._id || invite.owner;
    
    if (inviteTenantId.toString() !== userId.toString() && 
        inviteOwnerId.toString() !== userId.toString()) {
      return res.status(403).json({
        success: false,
        message: "Unauthorized to access this chat"
      });
    }

    if (!invite.chat) {
      return res.status(404).json({
        success: false,
        message: "Chat not yet created for this invite"
      });
    }

    // Return chat ID for frontend to redirect to chat
    res.json({
      success: true,
      message: "Chat found successfully",
      data: {
        chatId: invite.chat._id,
        inviteStatus: invite.status
      }
    });

  } catch (error) {
    console.error('Get chat from invite error:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};

// Send Real-time Message in Tenancy Invite
const sendInviteMessage = async (req, res) => {
  try {
    const { inviteId } = req.params;
    const { message, messageType = "text" } = req.body;
    const userId = req.user._id;

    if (!message || !message.trim()) {
      return res.status(400).json({
        success: false,
        message: "Message content is required"
      });
    }

    // Find and verify invite
    const invite = await TenancyInvite.findById(inviteId)
      .populate('property', 'title address')
      .populate('tenant', 'fullName profilePhoto phonenumber')
      .populate('owner', 'fullName profilePhoto phonenumber');

    if (!invite) {
      return res.status(404).json({
        success: false,
        message: "Tenancy invite not found"
      });
    }

    // Check if user is participant
    const inviteTenantId = invite.tenant._id || invite.tenant;
    const inviteOwnerId = invite.owner._id || invite.owner;
    const isOwner = inviteOwnerId.toString() === userId.toString();
    const isTenant = inviteTenantId.toString() === userId.toString();

    if (!isOwner && !isTenant) {
      return res.status(403).json({
        success: false,
        message: "Unauthorized to send message on this invite"
      });
    }

    // Check if invite is still active for messaging
    if (invite.status === 'expired') {
      return res.status(400).json({
        success: false,
        message: "Cannot send message on expired invite"
      });
    }

    // Create message object
    const inviteMessage = {
      _id: Date.now().toString(),
      inviteId: inviteId,
      sender: {
        _id: userId,
        fullName: req.user.fullName,
        userType: req.user.userType,
        profilePhoto: req.user.profilePhoto
      },
      message: message.trim(),
      messageType: messageType,
      timestamp: new Date(),
      property: {
        _id: invite.property._id,
        title: invite.property.title,
        address: invite.property.address
      }
    };

    // Send real-time message to participants
    const io = req.app.get('io');
    if (io) {
      const recipientId = isOwner ? inviteTenantId.toString() : inviteOwnerId.toString();
      const inviteRoom = `invite-${inviteId}`;
      
      // Send to recipient
      io.to(recipientId).emit('new-invite-message', {
        ...inviteMessage,
        isFromSender: false
      });
      
      // Send to invite room (if both users are in the conversation)
      io.to(inviteRoom).emit('new-invite-message', {
        ...inviteMessage,
        isFromSender: false
      });

      // Send confirmation to sender
      io.to(userId.toString()).emit('invite-message-sent', {
        ...inviteMessage,
        isFromSender: true
      });

      console.log(`[INVITE MESSAGE] User ${req.user.fullName} sent message on invite ${inviteId}`);
    }

    res.json({
      success: true,
      message: "Invite message sent successfully",
      data: inviteMessage
    });

  } catch (error) {
    console.error('Send invite message error:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};

// Get Invite Message History
const getInviteMessages = async (req, res) => {
  try {
    const { inviteId } = req.params;
    const userId = req.user._id;

    // Find and verify invite
    const invite = await TenancyInvite.findById(inviteId)
      .populate('property', 'title address')
      .populate('tenant', 'fullName profilePhoto')
      .populate('owner', 'fullName profilePhoto');

    if (!invite) {
      return res.status(404).json({
        success: false,
        message: "Tenancy invite not found"
      });
    }

    // Check if user is participant
    const inviteTenantId = invite.tenant._id || invite.tenant;
    const inviteOwnerId = invite.owner._id || invite.owner;

    if (inviteTenantId.toString() !== userId.toString() && 
        inviteOwnerId.toString() !== userId.toString()) {
      return res.status(403).json({
        success: false,
        message: "Unauthorized to view invite messages"
      });
    }

    // For now, we'll return system-generated messages based on invite status
    const messages = [];
    
    // Initial invite message
    messages.push({
      _id: `${inviteId}-initial`,
      inviteId: inviteId,
      sender: {
        _id: invite.owner._id,
        fullName: invite.owner.fullName,
        userType: 'owner',
        profilePhoto: invite.owner.profilePhoto
      },
      message: invite.autoGeneratedMessage || invite.message,
      messageType: 'invite',
      timestamp: invite.createdAt,
      property: {
        _id: invite.property._id,
        title: invite.property.title,
        address: invite.property.address
      }
    });

    // Response message if accepted/declined
    if (invite.status === 'accepted' && invite.tenantResponse?.message) {
      messages.push({
        _id: `${inviteId}-response`,
        inviteId: inviteId,
        sender: {
          _id: invite.tenant._id,
          fullName: invite.tenant.fullName,
          userType: 'tenant',
          profilePhoto: invite.tenant.profilePhoto
        },
        message: invite.tenantResponse.message,
        messageType: 'acceptance',
        timestamp: invite.tenantResponse.timestamp,
        property: {
          _id: invite.property._id,
          title: invite.property.title,
          address: invite.property.address
        }
      });
    } else if (invite.status === 'declined' && invite.tenantResponse?.message) {
      messages.push({
        _id: `${inviteId}-response`,
        inviteId: inviteId,
        sender: {
          _id: invite.tenant._id,
          fullName: invite.tenant.fullName,
          userType: 'tenant',
          profilePhoto: invite.tenant.profilePhoto
        },
        message: invite.tenantResponse.message,
        messageType: 'decline',
        timestamp: invite.tenantResponse.timestamp,
        property: {
          _id: invite.property._id,
          title: invite.property.title,
          address: invite.property.address
        }
      });
    }

    res.json({
      success: true,
      message: "Invite messages fetched successfully",
      data: {
        invite: invite,
        messages: messages
      }
    });

  } catch (error) {
    console.error('Get invite messages error:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};

module.exports = {
  sendTenancyInvite,
  getPendingInvitesForTenant,
  getAllInvitesForTenant,
  getInvitesByOwner,
  acceptTenancyInvite,
  declineTenancyInvite,
  getInviteDetails,
  getChatFromInvite,
  sendInviteMessage,
  getInviteMessages
};